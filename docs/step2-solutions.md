# Step 2. 해결 방법 나열

[← 이전: Step 1. 실무 상황 정의](step1-situation.md) | [README](../README.md) | [다음: Step 3. 기술적 의사결정 →](step3-decision.md)

---

> 클라이언트 레벨(버튼 비활성화 등)은 보조 수단일 뿐이므로 본 스터디에서는 서버 사이드 해결에 집중합니다.

## 후보 방법

| 방법 | 계층 | 간략 설명 |
|------|------|-----------|
| Redis SETNX | 인프라 레벨 | 요청 단위로 분산 락을 걸어 첫 번째 요청만 통과 |
| Idempotency Key | 비즈니스 레벨 | 클라이언트가 고유 키를 생성하여 서버에서 중복 체크, 이전 결과 반환 |
| DB 유니크 제약조건 | DB 레벨 | 비즈니스 키 조합에 유니크 인덱스를 걸어 중복 INSERT 차단 |
| 비관적 락 (SELECT FOR UPDATE) | DB 레벨 | SELECT 시점에 배타 락을 걸어 동시 접근 차단 |
| 애플리케이션 레벨 동기화 | 애플리케이션 레벨 | synchronized, ConcurrentHashMap 등으로 메모리 내 락 |
| 메시지 큐 (SQS 등) | 인프라 레벨 | 요청을 큐에 넣어 직렬화, 큐 레벨에서 중복 제거 |

## 후보별 검토 포인트

각 방법에 대해 아래 포인트를 스터디에서 검토하고, 선정/제외 근거를 각자 정리합니다.

### DB 유니크 제약조건

- 유니크 인덱스 자체의 비용은 어느 정도인가? (INSERT마다 인덱스 조회, 유지 비용 vs 실무에서의 실제 부담 수준)
- 비즈니스 키가 명확한 경우와 그렇지 않은 경우의 차이 (예: `user_id + card_type` vs 동일 상품 다른 옵션 주문)
- INSERT vs UPDATE에서의 방어 범위 차이
  - INSERT: `DuplicateKeyException`으로 확실한 방어
  - UPDATE: 유니크 제약이 막을 수 없음, Last Write Wins 발생, 부수 효과(알림, 포인트 등) 중복 실행 문제
- 범용 솔루션인가, 최종 방어선인가? 앞단의 요청 레벨 차단과 조합하는 구조는 어떤가?

### 메시지 큐 (SQS 등)

- 요청을 직렬화하면 동시성 자체가 사라지는 장점
- SQS FIFO의 `MessageDeduplicationId`를 통한 자동 중복 제거 (5분 이내)
- 동기 API에서의 구조적 한계 — 큐에 넣은 후 처리 결과를 HTTP 응답으로 돌려주는 방법의 복잡도
- 따닥 방어 수준 대비 인프라 도입 비용의 적절성
- 이 방식이 적합한 시나리오는 무엇인가? (대기열, 트래픽 폭주 등)

### 비관적 락 (SELECT FOR UPDATE)

- row가 존재하는 상태에서의 동시성 제어에는 유효
- 현재 시나리오처럼 row가 없는 상태에서 시작하면 락 대상이 없는 문제
- 별도 락 테이블 도입 시의 트레이드오프

### 애플리케이션 레벨 동기화 (synchronized 등)

- 단일 인스턴스에서는 가장 단순한 구현
- 다중 인스턴스 환경에서 동작하지 않는 근본적 한계

## Best Practice 선정

위 검토를 거쳐 아래 2가지를 Best Practice로 선정합니다.

| Best Practice | 관점 |
|---------------|------|
| **Redis SETNX** | 서버 단독 방어 — 서버가 키를 생성하고 중복 차단 |
| **Idempotency Key** | 클라이언트-서버 협력 방어 — 클라이언트가 키를 생성하고 서버가 결과 저장/반환 |

---

[← 이전: Step 1. 실무 상황 정의](step1-situation.md) | [README](../README.md) | [다음: Step 3. 기술적 의사결정 →](step3-decision.md)
