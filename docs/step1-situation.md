# Step 1. 실무 상황 정의

[← README로 돌아가기](../README.md) | [다음: Step 2. 해결 방법 나열 →](step2-solutions.md)

---

## 스터디 목적

클라이언트에서 버튼 중복 클릭을 완벽히 차단했다 하더라도, 서버에는 중복 요청이 충분히 들어올 수 있습니다.

- **HTTP 레벨 자동 재시도**: 클라이언트 라이브러리(Retrofit, OkHttp 등)의 retry 설정, 또는 로드밸런서/API Gateway(ALB, Nginx 등)의 retry 정책에 의해 동일 요청이 재전송되는 경우. 특히 서버가 요청을 처리 완료했지만 응답이 클라이언트에 도달하기 전에 연결이 끊기면, 클라이언트는 실패로 판단하고 재시도합니다.
- **네트워크 전환 (Wi-Fi ↔ 5G)**: 모바일 기기의 네트워크 전환 시 기존 TCP 연결이 끊어지고, 응답을 받지 못한 클라이언트의 복구 로직이 새 네트워크에서 동일 요청을 재전송하는 경우.

> **참고**: TCP 재송신(패킷 레벨)은 TCP 스택이 시퀀스 번호로 중복을 제거하므로, 애플리케이션 계층(HTTP)에 중복 요청을 만들지 않습니다.

이처럼 클라이언트 레벨에서 아무리 방어하더라도 서버 관점에서는 중복 요청을 피할 수 없으므,
서버 사이드에서의 방어 전략을 검증하기 위해 본 스터디를 진행합니다.

## 문제의 본질

- 일반적인 동시성 이슈: **서로 다른 유저 N명**이 **같은 자원**을 경쟁
- 따닥 요청 이슈: **같은 유저의 동일 의도**가 **중복 실행**

락(Lock)만으로는 해결되지 않습니다.
락은 실행 순서를 보장할 뿐, 두 번째 요청도 락을 획득하면 정상 실행되기 때문입니다.

## 실무 시나리오 — 뉴비 별점 평가 카드 조회 API (골든트리)

해당 회원이 조회할 평가 카드가 있는지 SELECT → 없으면 평가할 카드를 INSERT 하는 상황에서,
동일 요청이 중복으로 들어오면 카드가 2건 INSERT 되는 문제가 발생합니다.

인프라, 코드, 테이블 등은 실무 상황과 최대한 동일하게 조성합니다.

## "따닥 요청" 정의

| 항목 | 정의 |
|------|------|
| 시간 조건 | **500ms 이내**에 동일한 요청이 2회 이상 도착 |
| 동일 사용자 | 같은 유저의 요청 |
| 동일 요청 | Request Body가 완전히 동일한 POST 요청 |

## 재현 시나리오

```
시간축 →

[요청 1] POST /api/cards/evaluate  ──→ 서버 도착 (T+0ms)
         SELECT → 카드 없음 → INSERT ✅

[요청 2] POST /api/cards/evaluate  ──→ 서버 도착 (T+200ms)
         SELECT → 아직 카드 없음(요청1 미완료) → INSERT ✅ (중복!)

결과: 동일 평가 카드가 2건 생성
```

## 기대 결과

```
시간축 →

[요청 1] POST /api/cards/evaluate  ──→ 서버 도착 (T+0ms)
         SELECT → 카드 없음 → INSERT ✅ → 200 OK (카드 생성)

[요청 2] POST /api/cards/evaluate  ──→ 서버 도착 (T+200ms)
         중복 요청 감지 → INSERT 차단 ❌ → 409 Conflict 또는 기존 결과 반환

결과: 평가 카드 1건만 생성
```

---

[← README로 돌아가기](../README.md) | [다음: Step 2. 해결 방법 나열 →](step2-solutions.md)
